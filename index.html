<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vynix AI Training Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.0"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f8f8f8;
      --card-bg: #ffffff;
      --text-primary: #000000;
      --text-secondary: #666666;
      --border: #e0e0e0;
      --accent: #d40000;
      --bbm-red: #d40000;
      --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
      --glow: 0 0 10px rgba(212, 0, 0, 0.3);
    }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }
    .header {
      background: var(--card-bg);
      padding: 20px;
      text-align: center;
      box-shadow: var(--shadow-sm);
      border-bottom: 1px solid var(--border);
    }
    .header h1 {
      font-family: 'Orbitron', monospace;
      color: var(--bbm-red);
      font-weight: 900;
      font-size: 28px;
      letter-spacing: 0.5px;
      text-shadow: 0 0 10px rgba(212, 0, 0, 0.3);
      margin: 0;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .add-form, .bulk-form {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow-sm);
      margin-bottom: 20px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: end;
    }
    .add-form input {
      flex: 1;
      min-width: 200px;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 16px;
    }
    .bulk-form {
      flex-direction: column;
      gap: 12px;
      align-items: stretch;
    }
    .bulk-form input[type="file"] {
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: white;
    }
    .bulk-form textarea {
      flex: 1;
      min-height: 100px;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 14px;
      resize: vertical;
      font-family: monospace;
    }
    .bulk-preview {
      background: #f0f0f0;
      padding: 12px;
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
      font-size: 12px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    .btn {
      background: var(--bbm-red);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    .btn:hover {
      background: #b30000;
      box-shadow: var(--glow);
    }
    .btn-danger {
      background: #ff4444;
    }
    .btn-danger:hover {
      background: #cc0000;
    }
    .btn-secondary {
      background: #6b7280;
    }
    .btn-secondary:hover {
      background: #4b5563;
    }
    .stats {
      text-align: center;
      margin-bottom: 20px;
      font-size: 18px;
      color: var(--text-secondary);
    }
    .loading {
      text-align: center;
      padding: 40px;
      font-style: italic;
      color: var(--text-secondary);
    }
    .error {
      background: #fee;
      color: #c33;
      padding: 12px;
      border-radius: 6px;
      margin: 20px 0;
      border-left: 4px solid #c33;
    }
    .success {
      background: #efe;
      color: #080;
      padding: 12px;
      border-radius: 6px;
      margin: 20px 0;
      border-left: 4px solid #080;
    }
    .hidden {
      display: none !important;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-fill {
      height: 100%;
      background: var(--bbm-red);
      transition: width 0.3s ease;
      width: 0%;
    }
    .train-section {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow-sm);
      margin: 20px 0;
      text-align: center;
    }
    .train-status, .model-status {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow-sm);
      margin-bottom: 20px;
      max-height: 300px;
      overflow-y: auto;
    }
    .model-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
      align-items: center;
    }
    .model-options label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 15px;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      color: var(--text-secondary);
    }
    .slider-container input[type="range"] {
      flex: 1;
    }
    /* Overlay Spinner Styles */
    .overlay-spinner {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(248, 248, 248, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }
    .overlay-spinner.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .spinner {
      border: 4px solid var(--border);
      border-top: 4px solid var(--bbm-red);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .spinner-text {
      margin-top: 20px;
      font-family: 'Orbitron', monospace;
      color: var(--bbm-red);
      font-weight: 700;
      font-size: 16px;
      letter-spacing: 0.5px;
    }
    .btn-group {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <!-- Overlay Spinner -->
  <div id="overlay-spinner" class="overlay-spinner">
    <div class="spinner"></div>
    <div class="spinner-text" id="spinner-text">Initializing Vynix Dashboard...</div>
  </div>

  <header class="header">
    <h1>Vynix AI Training Dashboard</h1>
    <p>Manage training data for your AI companion</p>
  </header>

  <div class="container">
    <div id="auth-status" class="stats">Loading...</div>
    <div id="stats" class="stats hidden">Total texts: <span id="text-count">0</span></div>

    <div id="error-message" class="error hidden"></div>
    <div id="success-message" class="success hidden"></div>

    <form id="add-form" class="add-form hidden">
      <input type="text" id="new-text" placeholder="Text (e.g., 'The quick brown fox jumps.')" required>
      <input type="number" id="new-label" placeholder="Label (optional, e.g., 1 for positive)" min="0">
      <button type="submit" class="btn">Add Text</button>
    </form>

    <form id="bulk-form" class="bulk-form hidden">
      <div>
        <label for="bulk-input" class="block text-sm font-medium text-gray-700 mb-2">Bulk Upload Options</label>
        <div class="flex gap-4 mb-4">
          <label class="flex items-center">
            <input type="radio" name="bulk-mode" value="csv" checked class="mr-2">
            CSV File (text,label per line)
          </label>
          <label class="flex items-center">
            <input type="radio" name="bulk-mode" value="text" class="mr-2">
            Text (text|label per line)
          </label>
        </div>
      </div>
      <input type="file" id="bulk-input" accept=".csv,.txt" placeholder="Upload CSV or TXT file">
      <textarea id="bulk-text" placeholder="Or paste bulk data here (one entry per line: text|label)" style="display: none;"></textarea>
      <div id="bulk-preview" class="bulk-preview hidden">Preview will appear here...</div>
      <div class="progress-bar hidden">
        <div id="progress-fill" class="progress-fill"></div>
      </div>
      <button type="submit" class="btn" id="bulk-submit" disabled>Bulk Add Texts</button>
    </form>

    <div id="loading" class="loading hidden">Loading training data...</div>
    <div id="texts-list" class="hidden"></div>

    <div class="btn-group hidden">
      <button id="clear-all-btn" class="btn btn-danger">Clear All Training Data</button>
      <button id="retrain-btn" class="btn">Trigger Retrain (Saves & Notifies)</button>
    </div>

    <!-- Dynamic Train Section -->
    <div id="train-section" class="hidden"></div>
    <div id="train-status" class="train-status hidden"></div>
    <div id="model-status" class="model-status hidden"></div>

    <!-- HF Model Inference Section -->
    <div id="hf-inference" class="train-section hidden">
      <h3 class="text-lg font-bold mb-4 text-center">HF Pre-trained Chat Inference</h3>
      <div class="model-options">
        <label>
          <input type="radio" name="hf-model" value="Xenova/DialoGPT-medium" checked> DialoGPT (Chat-Focused)
        </label>
        <label>
          <input type="radio" name="hf-model" value="Xenova/distilgpt2"> DistilGPT-2 (General Text-Gen)
        </label>
        <div class="slider-container">
          <span>Max Tokens:</span>
          <input type="range" id="max-tokens" min="20" max="100" value="50" step="10">
          <span id="tokens-value">50</span>
        </div>
      </div>
      <textarea id="hf-prompt" placeholder="Enter a question or prompt (e.g., 'Hello, tell me a joke')" rows="3" class="w-full p-2 border rounded"></textarea>
      <button id="hf-generate-btn" class="btn">Generate Response with HF Model</button>
      <div id="hf-output" class="mt-4 p-4 bg-gray-100 rounded hidden"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, signOut } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
    import { getDatabase, ref, set, push, onValue, remove, update, get } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js";
    import { pipeline } from "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2";

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.firebasestorage.app",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e",
      measurementId: "G-V4W97VMSKL"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    const container = document.querySelector('.container');
    const elements = {
      overlaySpinner: document.getElementById('overlay-spinner'),
      spinnerText: document.getElementById('spinner-text'),
      authStatus: document.getElementById('auth-status'),
      stats: document.getElementById('stats'),
      textCount: document.getElementById('text-count'),
      errorMessage: document.getElementById('error-message'),
      successMessage: document.getElementById('success-message'),
      addForm: document.getElementById('add-form'),
      newText: document.getElementById('new-text'),
      newLabel: document.getElementById('new-label'),
      bulkForm: document.getElementById('bulk-form'),
      bulkInput: document.getElementById('bulk-input'),
      bulkText: document.getElementById('bulk-text'),
      bulkPreview: document.getElementById('bulk-preview'),
      bulkSubmit: document.getElementById('bulk-submit'),
      progressFill: document.getElementById('progress-fill'),
      loading: document.getElementById('loading'),
      textsList: document.getElementById('texts-list'),
      clearAllBtn: document.getElementById('clear-all-btn'),
      retrainBtn: document.getElementById('retrain-btn'),
      btnGroup: container.querySelector('.btn-group'),
      trainSection: document.getElementById('train-section'),
      trainStatus: document.getElementById('train-status'),
      modelStatus: document.getElementById('model-status'),
      hfInference: document.getElementById('hf-inference')
    };

    let currentUser;
    let trainingData = [];
    let dataLoaded = false;
    let models = {};
    let currentModelId = null;

    // VOCAB SETTINGS - Further reduced for efficiency
    let MAX_VOCAB = 200;
    const MAX_SEQ_LEN = 30; // Reduced max sequence length
    const STOPWORDS = new Set(['the','a','an','and','or','but','in','on','at','to','for','of','with','is','are','was','were','i','you','he','she','it','we','they','this','that','what','how','why','when','where','my','your','his','her','its','our','their','me','him','us','them','be','have','do','does','did','will','would','can','could','should','may','might','must']);

    // HF Inference Setup
    let hfPipeline = null;  // Cache the loaded model

    // Overlay functions
    function showOverlay(text = 'Loading...') {
      elements.spinnerText.textContent = text;
      elements.overlaySpinner.classList.remove('hidden');
    }

    function hideOverlay() {
      elements.overlaySpinner.classList.add('hidden');
    }

    function showError(msg) {
      elements.errorMessage.textContent = msg;
      elements.errorMessage.classList.remove('hidden');
      elements.successMessage.classList.add('hidden');
    }

    function showSuccess(msg) {
      elements.successMessage.textContent = msg;
      elements.successMessage.classList.remove('hidden');
      elements.errorMessage.classList.add('hidden');
    }

    function hideMessages() {
      elements.errorMessage.classList.add('hidden');
      elements.successMessage.classList.add('hidden');
    }

    function updateStats() {
      elements.textCount.textContent = trainingData.length;
      elements.stats.classList.remove('hidden');
    }

    function renderTexts() {
      // No longer rendering the list of texts to avoid clutter
      updateStats();
    }

    async function addText(text, label = null) {
      if (!currentUser || !text.trim()) {
        throw new Error('Please log in and enter text.');
      }
      const rawTextRef = ref(db, 'raw_text_data');
      // Check for duplicate text (case-insensitive)
      const snapshot = await get(rawTextRef);
      const existingData = snapshot.val() || [];
      const normalizedText = text.trim().toLowerCase();
      const existing = existingData.some(item => item.text.toLowerCase() === normalizedText);
      if (existing) {
        throw new Error('Duplicate text already exists. Please use different text.');
      }
      const newTextRef = push(rawTextRef);
      const newItem = { text: text.trim(), label: label ? parseInt(label) : null, timestamp: Date.now() };
      await set(newTextRef, newItem);
      return newItem;
    }

    window.clearAllData = async function() {
      if (!currentUser) return;
      if (!confirm('Delete ALL training data? This cannot be undone.')) return;
      try {
        hideMessages();
        elements.clearAllBtn.textContent = 'Clearing...';
        const rawTextRef = ref(db, 'raw_text_data');
        await remove(rawTextRef);
        showSuccess('All training data cleared successfully!');
        elements.clearAllBtn.textContent = 'Clear All Training Data';
      } catch (error) {
        showError('Failed to clear data: ' + error.message);
        elements.clearAllBtn.textContent = 'Clear All Training Data';
      }
    };

    async function triggerRetrain() {
      showSuccess('Training data saved! Vynix will retrain automatically in connected apps.');
    }

    // TF.js Helpers
    function textToVector(text, vocab) {
      const vec = new Array(vocab.length).fill(0);
      const words = text.toLowerCase().split(/\s+/).filter(w => w.length > 1);
      words.forEach(word => {
        const idx = vocab.indexOf(word);
        if (idx > -1) vec[idx] = 1;
      });
      return vec;
    }

    function questionToSequence(text, wordToIdx, maxLen) {
      const words = text.toLowerCase().split(/\s+/).filter(w => w.length > 1);
      let seq = words.map(w => wordToIdx.get(w) || 1);
      seq = seq.concat(Array(maxLen - seq.length).fill(0));
      return seq.slice(0, maxLen);
    }

    function buildVocabFromTexts(texts) {
      const wordCount = {};
      texts.forEach(text => {
        text.toLowerCase().split(/\s+/).forEach(word => {
          if (word.length > 2 && !STOPWORDS.has(word)) {
            wordCount[word] = (wordCount[word] || 0) + 1;
          }
        });
      });

      return Object.keys(wordCount)
        .filter(w => wordCount[w] >= 2)
        .sort()
        .slice(0, MAX_VOCAB);
    }

    function encodeLabels(items, uniqueLabels) {
      const labelToIdx = {};
      uniqueLabels.forEach((lbl, idx) => { labelToIdx[lbl] = idx; });
      return items.map(item => labelToIdx[item.label]);
    }

    async function loadModelFromSaved(saved) {
      let model;
      if (saved.taskType === 'classifier') {
        model = tf.sequential({
          layers: [
            tf.layers.dense({ inputShape: [saved.inputDim], units: 16, activation: 'relu' }),
            tf.layers.dropout({ rate: 0.3 }),
            tf.layers.dense({ units: saved.numClasses, activation: 'softmax' })
          ]
        });
      } else {
        model = tf.sequential({
          layers: [
            tf.layers.embedding({
              inputDim: saved.vocabSize,
              outputDim: saved.embedDim || 8,
              inputLength: saved.maxLen
            }),
            tf.layers.gru({ // Switched to GRU for efficiency
              units: saved.gruUnits || 16,
              dropout: 0.3
            }),
            tf.layers.dense({ units: saved.numClasses, activation: 'softmax' })
          ]
        });
      }
      model.compile({
        optimizer: tf.train.adam(0.001), // Explicit learning rate
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy']
      });

      const weightTensors = saved.weights.map(arr => tf.tensor(arr));
      model.setWeights(weightTensors);
      weightTensors.forEach(t => t.dispose());

      return { model, vocab: saved.vocab, uniqueLabels: saved.uniqueLabels, taskType: saved.taskType };
    }

    async function trainModel() {
      if (trainingData.length < 5) {
        showError('Need at least 5 training texts for a basic model.');
        return;
      }

      elements.trainStatus.classList.remove('hidden');
      elements.trainStatus.innerHTML = '<p class="loading">Preparing data... (Enable WebGL for faster training)</p>';
      elements.modelStatus.classList.add('hidden');

      try {
        await tf.setBackend('webgl');
        await tf.ready();

        const texts = trainingData.map(item => item.text);
        const hasLabels = trainingData.some(item => item.label !== null);
        const taskType = document.querySelector('input[name="task-type"]:checked').value;
        const retrain = document.getElementById('retrain-toggle').checked;
        let model, xs, ys, sampleInput, vocab, vocabSize, maxLen, isLoaded = false;

        const modelNameInput = document.getElementById('model-name');
        let modelName = modelNameInput ? modelNameInput.value.trim() : '';

        // Compute next version
        const modelsSnap = await get(ref(db, 'models'));
        const allModels = modelsSnap.val() || {};
        let nextVersion = 1;
        Object.values(allModels).forEach(m => {
          if (m.version) {
            const v = parseInt(m.version);
            if (!isNaN(v) && v >= nextVersion) nextVersion = v + 1;
          }
        });

        const currentIdRef = ref(db, 'currentModelId');
        const currentSnap = await get(currentIdRef);
        let modelRef;

        if (retrain && currentSnap.exists()) {
          const currentId = currentSnap.val();
          modelRef = ref(db, `models/${currentId}`);
          const snap = await get(modelRef);
          if (snap.exists() && snap.val().taskType === taskType) {
            const saved = snap.val();
            let savedVocab;
            if (taskType === 'classifier') {
              savedVocab = saved.vocab;
              const textVecs = texts.map(t => textToVector(t, savedVocab));
              xs = tf.tensor2d(textVecs);
              sampleInput = tf.tensor2d([textToVector('hello how are you today', savedVocab)]);
              vocabSize = savedVocab.length;
            } else {
              savedVocab = saved.vocab;
              const wordToIdx = new Map([['<PAD>', 0], ['<UNK>', 1]]);
              savedVocab.forEach((word, i) => wordToIdx.set(word, i + 2));
              maxLen = saved.maxLen;
              const sequences = texts.map(t => questionToSequence(t, wordToIdx, maxLen));
              xs = tf.tensor2d(sequences);
              sampleInput = tf.tensor2d([questionToSequence('hello how are you today', wordToIdx, maxLen)]);
              vocabSize = saved.vocabSize;
            }
            const loadedStuff = await loadModelFromSaved(saved);
            model = loadedStuff.model;
            vocab = savedVocab;
            elements.trainStatus.innerHTML += '<p>Loaded existing model for retraining.</p>';
            isLoaded = true;
          } else {
            elements.trainStatus.innerHTML += '<p>Current model incompatible or not found. Training new model from scratch.</p>';
          }
        } else if (retrain) {
          elements.trainStatus.innerHTML += '<p>No current model found. Training new model from scratch.</p>';
        }

        if (!isLoaded) {
          vocab = buildVocabFromTexts(texts);
          vocabSize = vocab.length + 2; // + <PAD>, <UNK>

          const wordToIdx = new Map([['<PAD>', 0], ['<UNK>', 1]]);
          vocab.forEach((word, i) => wordToIdx.set(word, i + 2));
          maxLen = Math.min(MAX_SEQ_LEN, Math.max(10, ...texts.map(t => 
            t.toLowerCase().split(/\s+/).filter(w => w.length > 1).length
          )));

          if (taskType === 'classifier' && hasLabels) {
            const uniqueLabels = [...new Set(trainingData.map(item => item.label).filter(l => l !== null))];
            const labelIndices = encodeLabels(trainingData, uniqueLabels);
            ys = tf.oneHot(tf.tensor1d(labelIndices, 'int32'), uniqueLabels.length);
            const sequences = texts.map(t => questionToSequence(t, wordToIdx, maxLen));
            xs = tf.tensor2d(sequences);
            sampleInput = tf.tensor2d([questionToSequence('hello how are you today', wordToIdx, maxLen)]);
            model = tf.sequential({
              layers: [
                tf.layers.embedding({ inputDim: vocabSize, outputDim: 8, inputLength: maxLen }),
                tf.layers.gru({ units: 16, dropout: 0.3 }),
                tf.layers.dense({ units: uniqueLabels.length, activation: 'softmax' })
              ]
            });
          } else {
            // Language Model (next-word prediction, no labels needed)
            const sequences = texts.map(text => {
              const words = text.toLowerCase().split(/\s+/).filter(w => w.length > 1);
              return words.map(w => wordToIdx.get(w) || 1);
            }).filter(seq => seq.length >= 2);

            const inputSeqs = [], targetSeqs = [];
            sequences.forEach(seq => {
              for (let i = 0; i < seq.length - 1; i++) {
                const inputSlice = seq.slice(i, Math.min(i + maxLen, seq.length)).concat(Array(maxLen - Math.min(i + maxLen, seq.length) + i).fill(0));
                inputSeqs.push(inputSlice);
                const targetSlice = seq.slice(i + 1, Math.min(i + 1 + maxLen, seq.length)).concat(Array(maxLen - Math.min(i + 1 + maxLen, seq.length) + (i + 1)).fill(0));
                targetSeqs.push(targetSlice);
              }
            });

            xs = tf.tensor2d(inputSeqs);
            ys = tf.oneHot(tf.tensor2d(targetSeqs), vocabSize);
            sampleInput = tf.tensor2d([questionToSequence('hello how are you today', wordToIdx, maxLen)]);
            model = tf.sequential({
              layers: [
                tf.layers.embedding({ inputDim: vocabSize, outputDim: 16, inputLength: maxLen }),
                tf.layers.gru({ units: 32, dropout: 0.3, returnSequences: true }),
                tf.layers.globalAveragePooling1d(),
                tf.layers.dense({ units: vocabSize, activation: 'softmax' })
              ]
            });
          }

          model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'categoricalCrossentropy',
            metrics: ['accuracy']
          });
        }

        const gruInfo = taskType === 'lm' ? ` | Max len: ${maxLen} | Task: Next-word prediction` : ` | Labels: ${hasLabels ? trainingData.filter(item => item.label !== null).length : 0}`;
        elements.trainStatus.innerHTML += `<p>Model type: ${taskType} | Vocab size: ${vocabSize}${gruInfo}</p>`;
        elements.trainStatus.innerHTML += `<p>Creating version ${nextVersion}</p>`;

        let finalAcc = 0;
        let bestValAcc = 0;
        let patience = 3;
        let wait = 0;
        await model.fit(xs, ys, {
          epochs: retrain ? 8 : 15,
          batchSize: Math.min(64, Math.max(xs.shape[0], 1)),
          validationSplit: 0.2,
          callbacks: {
            onEpochEnd: (epoch, logs) => {
              finalAcc = logs.acc;
              const valAcc = logs.val_acc;
              elements.trainStatus.innerHTML += `<p>Epoch ${epoch + 1}: Loss=${logs.loss.toFixed(4)}, Acc=${logs.acc.toFixed(4)}, Val Acc=${valAcc.toFixed(4)}</p>`;
              if (valAcc > bestValAcc) {
                bestValAcc = valAcc;
                wait = 0;
              } else {
                wait++;
                if (wait >= patience) {
                  elements.trainStatus.innerHTML += `<p>Early stopping at epoch ${epoch + 1}</p>`;
                  throw new Error('Early stopping');
                }
              }
            }
          }
        }).catch(err => {
          if (err.message !== 'Early stopping') throw err;
        });

        const pred = model.predict(sampleInput);
        const predIdx = pred.argMax(-1).dataSync()[0];
        let predicted;
        if (taskType === 'lm') {
          const vocabList = ['<PAD>', '<UNK>', ...vocab];
          predicted = vocabList[predIdx];
        } else {
          // For classifier, assume uniqueLabels from saved or compute
          const uniqueLabels = [...new Set(trainingData.map(item => item.label).filter(l => l !== null))];
          predicted = uniqueLabels[predIdx] || 'N/A';
        }
        elements.trainStatus.innerHTML += `<p>Test ("hello how are you today"): Predicted "${predicted}"</p>`;

        const weights = model.getWeights().map(w => w.arraySync());

        if (!modelName) {
          modelName = `vinaq v${nextVersion}`;
        }

        const saveData = {
          taskType,
          version: nextVersion,
          modelName,
          userId: currentUser.uid,
          timestamp: Date.now(),
          vocab,
          numClasses: taskType === 'lm' ? vocabSize : (hasLabels ? [...new Set(trainingData.map(item => item.label).filter(l => l !== null))].length : 0),
          weights
        };
        if (taskType === 'classifier') {
          saveData.inputDim = vocabSize;
          saveData.uniqueLabels = hasLabels ? [...new Set(trainingData.map(item => item.label).filter(l => l !== null))] : [];
        } else {
          saveData.vocabSize = vocabSize;
          saveData.maxLen = maxLen;
          saveData.embedDim = taskType === 'lm' ? 16 : 8;
          saveData.gruUnits = taskType === 'lm' ? 32 : 16;
        }

        // Always save as new version
        const modelsRef = ref(db, 'models');
        modelRef = push(modelsRef);
        await set(modelRef, saveData);
        await set(ref(db, 'currentModelId'), modelRef.key);

        elements.trainStatus.innerHTML += '<p>Loading saved model for verification...</p>';
        const savedSnapshot = await get(modelRef);
        const saved = savedSnapshot.val();
        const loadedStuff = await loadModelFromSaved(saved);
        const loadedModel = loadedStuff.model;

        const loadedPred = loadedModel.predict(sampleInput);
        const loadedPredIdx = loadedPred.argMax(-1).dataSync()[0];
        let loadedPredicted;
        if (taskType === 'lm') {
          const vocabList = ['<PAD>', '<UNK>', ...saved.vocab];
          loadedPredicted = vocabList[loadedPredIdx];
        } else {
          loadedPredicted = saved.uniqueLabels[loadedPredIdx] || 'N/A';
        }
        elements.trainStatus.innerHTML += `<p>Verification: Loaded model predicts "${loadedPredicted}"</p>`;

        elements.modelStatus.innerHTML = `<p class="success">Model: ${taskType.toUpperCase()} ${modelName} (v${saved.version}) trained & saved! Final Accuracy: ~${(finalAcc * 100).toFixed(1)}%</p><p>Model format: Custom. Use in chat UI with loadModelFromSaved function.</p>`;
        elements.modelStatus.classList.remove('hidden');
        showSuccess('Training completeâ€”model ready for your chat UI.');

        xs.dispose();
        ys.dispose();
        pred.dispose();
        loadedPred.dispose();
        model.dispose();
        loadedModel.dispose();
        sampleInput.dispose();

      } catch (error) {
        if (error.message !== 'Early stopping') {
          elements.trainStatus.innerHTML += `<p class="error">Training failed: ${error.message}</p>`;
          showError('Training error: ' + error.message);
          console.error('Training error:', error);
        }
      }
    }

    async function loadHFPipeline(modelId = 'Xenova/DialoGPT-medium') {
      if (!hfPipeline) {
        elements.trainStatus.innerHTML += '<p>Loading HF model... (First time may take 30-60s)</p>';
        try {
          // Use WebGPU if supported for speed; fallback to WASM
          const device = 'webgpu' in navigator ? 'webgpu' : 'wasm';
          const dtype = 'fp16';  // Half-precision for balance (or 'q4' for quantized speed)
          
          hfPipeline = await pipeline('text-generation', modelId, {
            device: device,
            dtype: dtype,
            progress_callback: (data) => {
              elements.trainStatus.innerHTML += `<p>Model progress: ${data.loaded}/${data.total}</p>`;
            }
          });
          elements.trainStatus.innerHTML += `<p>HF Model "${modelId}" loaded successfully!</p>`;
          showSuccess('Ready to chat with pre-trained model!');
        } catch (error) {
          showError(`Failed to load HF model: ${error.message}. Try a smaller model or check browser support.`);
        }
      }
      return hfPipeline;
    }

    async function generateHFResponse(prompt, maxTokens = 50) {
      if (!hfPipeline) {
        showError('Load a model first!');
        return;
      }
      
      const outputEl = document.getElementById('hf-output');
      outputEl.classList.remove('hidden');
      outputEl.innerHTML = '<p class="loading">Generating... (Patience, it's thinking!)</p>';
      
      try {
        const output = await hfPipeline(prompt, {
          max_new_tokens: maxTokens,
          temperature: 0.7,  // Creativity level (0.1=deterministic, 1.0=wild)
          do_sample: true,   // Enable sampling for varied responses
          pad_token_id: 50256  // For GPT-like models; adjust if needed
        });
        
        const generatedText = output[0].generated_text.replace(prompt, '').trim();  // Strip prompt for clean response
        outputEl.innerHTML = `<p><strong>Prompt:</strong> ${prompt}</p><p><strong>Response:</strong> ${generatedText}</p>`;
        showSuccess('Response generated!');
      } catch (error) {
        outputEl.innerHTML = `<p class="error">Generation failed: ${error.message}</p>`;
      }
    }

    function loadTrainingData() {
      showOverlay('Fetching training data...');
      const rawTextRef = ref(db, 'raw_text_data');
      onValue(rawTextRef, (snapshot) => {
        const data = snapshot.val() || [];
        trainingData = Array.isArray(data) ? data : [];
        renderTexts();
        elements.loading.classList.add('hidden');

        if (!dataLoaded) {
          dataLoaded = true;
          hideOverlay();
        }

        if (elements.trainSection.children.length === 0) {
          elements.trainSection.innerHTML = `
            <section class="train-section">
              <div class="model-options">
                <label>
                  <input type="checkbox" id="retrain-toggle"> Retrain existing model (no delete)
                </label>
                <label>
                  <input type="radio" name="task-type" value="lm" checked> Language Model (from raw text, next-word prediction)
                </label>
                <label>
                  <input type="radio" name="task-type" value="classifier"> Classifier (needs labels)
                </label>
                <div class="slider-container">
                  <span>Max Vocab:</span>
                  <input type="range" id="vocab-slider" min="50" max="500" value="200" step="50">
                  <span id="vocab-value">200</span>
                </div>
                <label class="block w-full">
                  <span class="text-sm font-medium">Model Name (optional)</span>
                  <input type="text" id="model-name" placeholder="e.g., vinaq v2" class="mt-1 block w-full rounded-md border border-gray-300 shadow-sm p-2">
                </label>
              </div>
              <button id="train-btn" class="btn">Train AI Model</button>
            </section>
          `;

          // Init slider
          const slider = document.getElementById('vocab-slider');
          const value = document.getElementById('vocab-value');
          slider.addEventListener('input', () => {
            MAX_VOCAB = parseInt(slider.value);
            value.textContent = MAX_VOCAB;
          });

          document.getElementById('train-btn').addEventListener('click', trainModel);

          // Insert models management
          const modelsHTML = `
            <div id="models-management" class="train-section hidden">
              <h3 class="text-lg font-bold mb-4 text-center">Available Models</h3>
              <div id="models-list" class="space-y-2 mb-4 max-h-60 overflow-y-auto"></div>
              <div class="btn-group">
                <button id="delete-selected-btn" class="btn btn-danger" disabled>Delete Selected</button>
              </div>
            </div>
          `;
          elements.trainSection.insertAdjacentHTML('afterend', modelsHTML);

          elements.modelsManagement = document.getElementById('models-management');
          elements.modelsList = document.getElementById('models-list');
          elements.deleteSelectedBtn = document.getElementById('delete-selected-btn');
          elements.deleteSelectedBtn.addEventListener('click', deleteSelectedModels);

          loadModels();
        }
        elements.trainSection.classList.remove('hidden');
        elements.hfInference.classList.remove('hidden');
        elements.modelsManagement?.classList.remove('hidden');
      }, (error) => {
        showError('Failed to load training data: ' + error.message);
        elements.loading.classList.add('hidden');
        if (!dataLoaded) {
          dataLoaded = true;
          hideOverlay();
        }
      });
    }

    function loadModels() {
      const modelsRef = ref(db, 'models');
      onValue(modelsRef, (snapshot) => {
        models = snapshot.val() || {};
        renderModels();
      }, (error) => {
        console.error('Failed to load models:', error);
      });

      const currentRef = ref(db, 'currentModelId');
      onValue(currentRef, (snapshot) => {
        currentModelId = snapshot.val();
        renderModels();
      }, (error) => {
        console.error('Failed to load current model ID:', error);
      });
    }

    function renderModels() {
      const list = elements.modelsList;
      if (!list) return;
      list.innerHTML = '';
      const modelEntries = Object.entries(models);
      if (modelEntries.length === 0) {
        list.innerHTML = '<p class="text-center text-gray-500 py-4">No models available. Train your first model!</p>';
        return;
      }
      modelEntries.forEach(([id, m]) => {
        const isCurrent = currentModelId === id;
        const div = document.createElement('div');
        div.className = `flex items-center justify-between p-4 bg-white rounded-lg shadow-sm border ${isCurrent ? 'border-blue-500' : 'border-gray-200'}`;
        const name = m.modelName || `vinaq v${m.version}`;
        const status = isCurrent ? '<span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs">Current</span>' : '';
        div.innerHTML = `
          <div class="flex items-center space-x-3 flex-1">
            <input type="checkbox" class="form-checkbox h-5 w-5 text-red-600" value="${id}" onchange="toggleDeleteBtn()">
            <div>
              <div class="font-medium">${name} ${status}</div>
              <div class="text-sm text-gray-600">
                Type: ${m.taskType} | Classes: ${m.numClasses || 'N/A'} | 
                ${new Date(m.timestamp).toLocaleDateString()}
              </div>
            </div>
          </div>
          <div class="flex space-x-2">
            ${!isCurrent ? `<button onclick="setCurrentModel('${id}')" class="btn btn-secondary text-sm px-3 py-1">Set Current</button>` : ''}
            <button onclick="deleteSingleModel('${id}')" class="btn btn-danger text-sm px-3 py-1">Delete</button>
          </div>
        `;
        list.appendChild(div);
      });
      toggleDeleteBtn();
    }

    window.toggleDeleteBtn = function() {
      const checked = document.querySelectorAll('#models-list input[type="checkbox"]:checked');
      const btn = elements.deleteSelectedBtn;
      if (btn) {
        btn.disabled = checked.length === 0;
        btn.textContent = checked.length > 0 ? `Delete Selected (${checked.length})` : 'Delete Selected';
      }
    };

    window.setCurrentModel = async function(id) {
      if (!currentUser) return;
      try {
        await set(ref(db, 'currentModelId'), id);
        showSuccess('Model set as current.');
      } catch (error) {
        showError('Failed to set current model: ' + error.message);
      }
    };

    window.deleteSingleModel = async function(id) {
      if (!currentUser || !confirm('Delete this model? This cannot be undone.')) return;
      try {
        await remove(ref(db, `models/${id}`));
        if (currentModelId === id) {
          await set(ref(db, 'currentModelId'), null);
        }
        showSuccess('Model deleted successfully.');
      } catch (error) {
        showError('Failed to delete model: ' + error.message);
      }
    };

    async function deleteSelectedModels() {
      if (!currentUser) return;
      const selected = Array.from(document.querySelectorAll('#models-list input:checked')).map(cb => cb.value);
      if (selected.length === 0 || !confirm(`Delete ${selected.length} model(s)? This cannot be undone.`)) return;
      try {
        await Promise.all(selected.map(id => remove(ref(db, `models/${id}`))));
        if (selected.includes(currentModelId)) {
          await set(ref(db, 'currentModelId'), null);
        }
        showSuccess(`${selected.length} model(s) deleted successfully.`);
      } catch (error) {
        showError('Failed to delete models: ' + error.message);
      }
    }

    // Bulk functionality (updated for text|label)
    function parseBulkData(content, mode) {
      let lines;
      if (mode === 'csv') {
        lines = content.split('\n').slice(1).filter(line => line.trim());
        return lines.map(line => {
          const parts = line.split(',').map(s => s.trim().replace(/"/g, ''));
          const text = parts[0];
          const label = parts[1] ? parseInt(parts[1]) : null;
          return { text, label };
        }).filter(item => item.text);
      } else {
        lines = content.split('\n').filter(line => line.trim());
        return lines.map(line => {
          const [text, labelStr] = line.split('|').map(s => s.trim());
          const label = labelStr ? parseInt(labelStr) : null;
          return { text, label };
        }).filter(item => item.text);
      }
    }

    function updateBulkPreview(items) {
      if (items.length === 0) {
        elements.bulkPreview.textContent = 'No valid texts found.';
        elements.bulkSubmit.disabled = true;
      } else {
        elements.bulkPreview.textContent = `${items.length} valid texts parsed:\n\n${items.slice(0, 10).map(item => `${item.text} | ${item.label || 'N/A'}`).join('\n')}${items.length > 10 ? '\n\n... (showing first 10)' : ''}`;
        elements.bulkSubmit.disabled = false;
      }
      elements.bulkPreview.classList.remove('hidden');
    }

    async function handleBulkSubmit(e) {
      e.preventDefault();
      const mode = document.querySelector('input[name="bulk-mode"]:checked').value;
      let content = '';

      if (mode === 'text') {
        content = elements.bulkText.value;
      } else {
        const file = elements.bulkInput.files[0];
        if (!file) {
          showError('Please select a file.');
          return;
        }
        const text = await file.text();
        content = text;
      }

      const items = parseBulkData(content, mode);
      if (items.length === 0) {
        showError('No valid texts found in the input.');
        return;
      }

      const progressBar = elements.progressFill.parentElement;
      progressBar.classList.remove('hidden');
      hideMessages();

      let added = 0;
      let skipped = 0;
      let errors = 0;
      const rawTextRef = ref(db, 'raw_text_data');
      const snapshot = await get(rawTextRef);
      const existingData = snapshot.val() || [];
      const existingTexts = new Set(existingData.map(item => item.text.toLowerCase()));

      for (let i = 0; i < items.length; i++) {
        try {
          const normalizedText = items[i].text.trim().toLowerCase();
          if (existingTexts.has(normalizedText)) {
            skipped++;
            continue;
          }
          await addText(items[i].text, items[i].label);
          existingTexts.add(normalizedText); // Update set for efficiency
          added++;
        } catch (error) {
          errors++;
          console.error(`Failed to add text ${i + 1}:`, error);
        }
        const progress = ((i + 1) / items.length) * 100;
        elements.progressFill.style.width = `${progress}%`;
      }

      progressBar.classList.add('hidden');
      elements.progressFill.style.width = '0%';

      let message = `Bulk upload complete: ${added} texts added`;
      if (skipped > 0) message += `, ${skipped} duplicates skipped`;
      if (errors > 0) message += `, ${errors} errors`;
      message += '.';
      showSuccess(message);
      if (mode === 'text') {
        elements.bulkText.value = '';
      } else {
        elements.bulkInput.value = '';
      }
      elements.bulkPreview.classList.add('hidden');
    }

    // Event listeners
    elements.addForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = elements.newText.value;
      const label = elements.newLabel.value ? parseInt(elements.newLabel.value) : null;
      addText(text, label).then(() => {
        elements.newText.value = '';
        elements.newLabel.value = '';
        showSuccess('Text added successfully!');
      }).catch(error => {
        showError(error.message);
      });
    });

    elements.retrainBtn.addEventListener('click', triggerRetrain);
    elements.clearAllBtn.addEventListener('click', clearAllData);

    elements.bulkForm.addEventListener('submit', handleBulkSubmit);

    const modeRadios = document.querySelectorAll('input[name="bulk-mode"]');
    modeRadios.forEach(radio => {
      radio.addEventListener('change', (e) => {
        const isText = e.target.value === 'text';
        elements.bulkInput.style.display = isText ? 'none' : 'block';
        elements.bulkText.style.display = isText ? 'block' : 'none';
        elements.bulkPreview.classList.add('hidden');
        elements.bulkSubmit.disabled = true;
      });
    });

    elements.bulkInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const content = await file.text();
      const items = parseBulkData(content, 'csv');
      updateBulkPreview(items);
    });

    elements.bulkText.addEventListener('input', (e) => {
      const content = e.target.value;
      const items = parseBulkData(content, 'text');
      updateBulkPreview(items);
    });

    // HF Event Listeners
    document.addEventListener('DOMContentLoaded', () => {
      const generateBtn = document.getElementById('hf-generate-btn');
      const modelRadios = document.querySelectorAll('input[name="hf-model"]');
      const maxTokensSlider = document.getElementById('max-tokens');
      const tokensValue = document.getElementById('tokens-value');
      
      // Slider update
      maxTokensSlider.addEventListener('input', () => {
        tokensValue.textContent = maxTokensSlider.value;
      });
      
      // Model radio change: Reload pipeline if switched
      modelRadios.forEach(radio => {
        radio.addEventListener('change', async () => {
          if (radio.checked) {
            hfPipeline = null;  // Reset cache
            await loadHFPipeline(radio.value);
          }
        });
      });
      
      // Generate button
      generateBtn.addEventListener('click', async () => {
        const prompt = document.getElementById('hf-prompt').value.trim();
        if (!prompt) {
          showError('Enter a prompt first!');
          return;
        }
        const maxTokens = parseInt(maxTokensSlider.value);
        await generateHFResponse(prompt, maxTokens);
      });
    });

    onAuthStateChanged(auth, (user) => {
      currentUser = user;
      if (user) {
        showOverlay('Authenticating...');
        elements.authStatus.innerHTML = `Logged in as: ${user.displayName || user.email || 'User'} <button class="btn btn-secondary" onclick="signOutUser()" style="font-size: 12px; padding: 4px 8px; margin-left: 10px;">Sign Out</button>`;
        elements.addForm.classList.remove('hidden');
        elements.bulkForm.classList.remove('hidden');
        elements.btnGroup.classList.remove('hidden');
        elements.trainSection.classList.remove('hidden');
        elements.hfInference.classList.remove('hidden');
        elements.modelsManagement?.classList.remove('hidden');
        loadTrainingData();
        if (currentUser) {
          loadHFPipeline();  // Pre-load default model
        }
      } else {
        hideOverlay();
        elements.authStatus.innerHTML = 'Not logged in. <button class="btn" onclick="signInAnonymously()">Sign In Anonymously</button>';
        elements.addForm.classList.add('hidden');
        elements.bulkForm.classList.add('hidden');
        elements.btnGroup.classList.add('hidden');
        elements.trainSection.classList.add('hidden');
        elements.hfInference.classList.add('hidden');
        elements.modelsManagement?.classList.add('hidden');
        elements.textsList.innerHTML = '<p class="loading">Please sign in to manage training data.</p>';
        elements.loading.classList.add('hidden');
      }
    });

    window.signInAnonymously = async function() {
      try {
        showOverlay('Signing in...');
        await signInAnonymously(auth);
      } catch (error) {
        showError('Sign in failed: ' + error.message);
        hideOverlay();
      }
    };

    window.signOutUser = async function() {
      try {
        await signOut(auth);
      } catch (error) {
        showError('Sign out failed: ' + error.message);
      }
    };

    // Initial load
    showOverlay('Connecting to Firebase...');
    elements.loading.classList.add('hidden');
  </script>
</body>
</html>
