<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vynix Sensor Alerts</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #1E3A8A;
      --accent: #000000;
      --bg: #0A0A0A;
      --card-bg: #1A1A1A;
      --text-primary: #F3F4F6;
      --text-secondary: #A3A3A3;
      --border: #2D2D2D;
      --highlight: #2A2A2A;
      --focus: #4B5EAA;
      --white: #FFFFFF;
      --error: #EF4444;
      --success: #10B981;
      --glow: rgba(0, 0, 0, 0.5);
      --black-hole-core: rgba(0, 0, 0, 1);
      --black-hole-disk: rgba(255, 165, 0, 0.3);
      --alert-bg: #B91C1C;
    }

    [data-theme="light"] {
      --bg: #F9FAFB;
      --card-bg: #FFFFFF;
      --text-primary: #111827;
      --text-secondary: #6B7280;
      --border: #D1D5DB;
      --highlight: #E5E7EB;
      --glow: rgba(0, 0, 0, 0.3);
      --black-hole-core: rgba(0, 0, 0, 1);
      --black-hole-disk: rgba(255, 165, 0, 0.4);
      --alert-bg: #FECACA;
    }

    body {
      font-family: 'Poppins', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      min-height: 100vh;
      margin: 0;
      transition: background 0.3s ease;
      touch-action: manipulation;
    }

    @media (prefers-reduced-motion: no-preference) {
      .transition { transition: all 0.3s ease; }
      .slide-in { animation: slideIn 0.3s ease; }
      .pulse-glow { animation: pulseGlow 2s infinite ease-in-out; }
      .black-hole { animation: blackHoleSwirl 10s infinite linear; }
      .modal-slide-in { animation: modalSlideIn 0.3s ease; }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes pulseGlow {
      0%, 100% { transform: scale(1); box-shadow: 0 0 10px var(--glow); }
      50% { transform: scale(1.05); box-shadow: 0 0 20px var(--glow); }
    }

    @keyframes blackHoleSwirl {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes modalSlideIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .alert {
      max-width: 80%;
      padding: 0.75rem;
      border-radius: 1rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      background: var(--alert-bg);
      color: var(--white);
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .toggle-container {
      position: fixed;
      top: 0.5rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      justify-content: center;
    }

    .alert-container {
      position: fixed;
      top: 3rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-width: 90%;
      width: 600px;
    }

    .black-hole-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 300px;
      pointer-events: none;
      z-index: 10;
    }

    .black-hole {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, var(--black-hole-core) 20%, var(--black-hole-disk) 50%, transparent);
      border-radius: 50%;
    }

    canvas.black-hole-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.8;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 30;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
      max-width: 90%;
      width: 400px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }

    .modal-content select {
      width: 100%;
      background: var(--highlight);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      padding: 0.5rem;
      color: var(--text-primary);
      outline: none;
      font-size: 0.875rem;
    }

    .modal-content select:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 2px var(--glow);
    }

    .modal-buttons {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 1rem;
    }

    @media (max-width: 640px) {
      .black-hole-container {
        width: 200px;
        height: 200px;
      }
      .alert-container {
        top: 2.5rem;
        width: 90%;
      }
      .alert {
        max-width: 90%;
        padding: 0.5rem;
        font-size: 0.875rem;
      }
      .toggle-container {
        top: 0.25rem;
      }
      .modal-content {
        width: 90%;
      }
      button, select {
        font-size: 0.875rem;
      }
    }
  </style>
</head>
<body data-theme="dark">
  <main class="sensor-container p-4 flex flex-col h-screen max-w-3xl mx-auto" id="sensor-container">
    <div class="toggle-container">
      <button id="theme-toggle" class="text-[var(--accent)] hover:scale-110 focus:outline focus:outline-2 focus:outline-[var(--focus)] p-2" aria-label="Toggle theme">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      </button>
      <button id="sensor-toggle" class="text-[var(--accent)] hover:scale-110 focus:outline focus:outline-2 focus:outline-[var(--focus)] p-2" aria-label="Toggle sensor detection">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 2v6m0 8v6m-6-6h12"></path>
        </svg>
      </button>
      <button id="settings-button" class="text-[var(--accent)] hover:scale-110 focus:outline focus:outline-2 focus:outline-[var(--focus)] p-2" aria-label="Open settings">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
      </button>
    </div>
    <div class="alert-container" id="alert-container" aria-live="polite" role="log"></div>
    <div class="black-hole-container" id="black-hole-container">
      <div class="black-hole"></div>
      <canvas id="black-hole-canvas" class="black-hole-canvas"></canvas>
    </div>
    <div id="settings-modal" class="modal" role="dialog" aria-labelledby="settings-modal-title" aria-describedby="settings-modal-description">
      <div class="modal-content modal-slide-in">
        <h2 id="settings-modal-title" class="text-lg font-semibold text-[var(--text-primary)] mb-2">Alert Settings</h2>
        <p id="settings-modal-description" class="text-sm text-[var(--text-secondary)] mb-4">Customize your proximity and orientation alerts</p>
        <label class="block mb-2">
          <span class="text-sm text-[var(--text-primary)]">Alert Sound Pitch</span>
          <select id="alert-pitch" class="mt-1">
            <option value="1000">High (1000 Hz)</option>
            <option value="500">Low (500 Hz)</option>
          </select>
        </label>
        <label class="block mb-2">
          <span class="text-sm text-[var(--text-primary)]">Vibration Pattern</span>
          <select id="vibration-pattern" class="mt-1">
            <option value="short">Short (200ms)</option>
            <option value="long">Long (200,100,200ms)</option>
          </select>
        </label>
        <label class="block mb-2">
          <span class="text-sm text-[var(--text-primary)]">Proximity Threshold</span>
          <select id="proximity-threshold" class="mt-1">
            <option value="5">Close (5 cm)</option>
            <option value="10">Far (10 cm)</option>
          </select>
        </label>
        <div class="modal-buttons">
          <button id="settings-cancel" class="px-3 py-1.5 bg-[var(--highlight)] text-[var(--text-primary)] rounded-lg hover:bg-[var(--border)] transition" aria-label="Cancel">Cancel</button>
          <button id="settings-save" class="px-3 py-1.5 bg-gradient-to-r from-[var(--primary)] to-[var(--accent)] text-white rounded-lg hover:scale-105 transition" aria-label="Save settings">Save</button>
        </div>
      </div>
    </div>
  </main>

  <script>
    const state = {
      theme: localStorage.getItem('theme') || 'dark',
      sensorDetectionEnabled: localStorage.getItem('sensorDetectionEnabled') === 'true' || false,
      alertPitch: localStorage.getItem('alertPitch') || '1000',
      vibrationPattern: localStorage.getItem('vibrationPattern') || 'short',
      proximityThreshold: localStorage.getItem('proximityThreshold') || '5',
      blackHoleAnimationFrame: null
    };

    const elements = {
      themeToggle: document.getElementById('theme-toggle'),
      sensorToggle: document.getElementById('sensor-toggle'),
      settingsButton: document.getElementById('settings-button'),
      settingsModal: document.getElementById('settings-modal'),
      settingsSave: document.getElementById('settings-save'),
      settingsCancel: document.getElementById('settings-cancel'),
      alertPitch: document.getElementById('alert-pitch'),
      vibrationPattern: document.getElementById('vibration-pattern'),
      proximityThreshold: document.getElementById('proximity-threshold'),
      alertContainer: document.getElementById('alert-container'),
      blackHoleContainer: document.getElementById('black-hole-container'),
      blackHoleCanvas: document.getElementById('black-hole-canvas')
    };

    // Initialize sensors for proximity and orientation
    function initializeSensors() {
      if ('DeviceMotionEvent' in window) {
        window.addEventListener('devicemotion', handleProximityFallback, true);
        console.log("DeviceMotionEvent initialized for proximity fallback");
      } else {
        showAlert("Device motion not supported on this device.");
      }

      if ('DeviceOrientationEvent' in window) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
        console.log("DeviceOrientationEvent initialized");
      } else {
        showAlert("Device orientation not supported on this device.");
      }

      if ('ProximitySensor' in window) {
        const proximity = new ProximitySensor();
        proximity.addEventListener('reading', () => {
          if (proximity.near && proximity.distance < parseInt(state.proximityThreshold)) {
            if (isDeviceUpright()) {
              showAlert(`Hand detected within ${proximity.distance} cm!`);
            } else {
              showAlert("Device not upright! Please hold upright.");
            }
          }
        });
        proximity.start();
      } else {
        console.log("ProximitySensor not supported, using accelerometer fallback");
      }
    }

    // Fallback for proximity detection using accelerometer
    let lastAcceleration = { x: 0, y: 0, z: 0 };
    function handleProximityFallback(event) {
      const { acceleration } = event;
      const deltaThreshold = 5;
      if (lastAcceleration.x !== 0) {
        const deltaX = Math.abs(acceleration.x - lastAcceleration.x);
        const deltaY = Math.abs(acceleration.y - lastAcceleration.y);
        const deltaZ = Math.abs(acceleration.z - lastAcceleration.z);
        if (deltaX > deltaThreshold || deltaY > deltaThreshold || deltaZ > deltaThreshold) {
          if (isDeviceUpright()) {
            showAlert("Sudden movement detected! Possible hand proximity!");
          } else {
            showAlert("Device not upright! Please hold upright.");
          }
        }
      }
      lastAcceleration = { ...acceleration };
    }

    // Check if device is upright
    let isUpright = true;
    function handleDeviceOrientation(event) {
      const { beta } = event;
      isUpright = beta > -30 && beta < 30;
      if (!isUpright && state.sensorDetectionEnabled) {
        showAlert("Device not upright! Please hold upright.");
      }
    }

    function isDeviceUpright() {
      return isUpright;
    }

    // Show alert with sound and vibration
    function showAlert(message) {
      playAlertSound();
      const pattern = state.vibrationPattern === 'short' ? [200] : [200, 100, 200];
      vibrate(pattern);
      const alert = document.createElement('div');
      alert.className = 'alert slide-in';
      alert.textContent = message;
      elements.alertContainer.appendChild(alert);
      setTimeout(() => alert.remove(), 5000);
    }

    // Play alert sound
    function playAlertSound() {
      const audioContext = new AudioContext();
      const oscillator = audioContext.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(parseInt(state.alertPitch), audioContext.currentTime);
      oscillator.connect(audioContext.destination);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.2);
    }

    // Vibration
    function vibrate(duration) {
      if ('vibrate' in navigator) {
        navigator.vibrate(duration);
      } else {
        console.log('Vibration not supported on this device');
      }
    }

    // Request sensor permissions
    async function requestSensorPermissions() {
      let motionGranted = true;
      let orientationGranted = true;

      if ('DeviceMotionEvent' in window && typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
          const response = await DeviceMotionEvent.requestPermission();
          motionGranted = response === 'granted';
        } catch (error) {
          showAlert("Failed to request motion sensor permissions.");
          console.error(error);
          motionGranted = false;
        }
      }

      if ('DeviceOrientationEvent' in window && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const response = await DeviceOrientationEvent.requestPermission();
          orientationGranted = response === 'granted';
        } catch (error) {
          showAlert("Failed to request orientation sensor permissions.");
          console.error(error);
          orientationGranted = false;
        }
      }

      if (motionGranted && orientationGranted) {
        initializeSensors();
      } else {
        showAlert("Sensor access denied.");
        state.sensorDetectionEnabled = false;
        localStorage.setItem('sensorDetectionEnabled', false);
        elements.sensorToggle.classList.remove('bg-[var(--success)]', 'text-white');
      }
    }

    // Show settings modal
    function showSettingsModal() {
      elements.settingsModal.style.display = 'flex';
      elements.alertPitch.value = state.alertPitch;
      elements.vibrationPattern.value = state.vibrationPattern;
      elements.proximityThreshold.value = state.proximityThreshold;
      elements.alertPitch.focus();
    }

    // Close settings modal
    function closeSettingsModal() {
      elements.settingsModal.style.display = 'none';
      elements.settingsSave.onclick = null;
      elements.settingsCancel.onclick = null;
    }

    // Black hole animation
    function startBlackHoleAnimation() {
      if (!elements.blackHoleCanvas || !elements.blackHoleContainer) {
        console.error("Black hole elements not found");
        return;
      }
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        elements.blackHoleContainer.classList.add('hidden');
        return;
      }
      elements.blackHoleContainer.classList.remove('hidden');
      const ctx = elements.blackHoleCanvas.getContext('2d');
      elements.blackHoleCanvas.width = window.innerWidth <= 640 ? 200 : 300;
      elements.blackHoleCanvas.height = window.innerWidth <= 640 ? 200 : 300;
      const particleCount = window.innerWidth <= 640 ? 100 : 200;
      const particles = Array.from({length: particleCount}, () => ({
        x: elements.blackHoleCanvas.width / 2,
        y: elements.blackHoleCanvas.height / 2,
        radius: Math.random() * 2 + 1,
        angle: Math.random() * Math.PI * 2,
        speed: Math.random() * 0.02 + 0.01,
        distance: Math.random() * 50 + 50,
        opacity: Math.random() * 0.5 + 0.3,
        color: `hsl(${Math.random() * 60 + 30}, 80%, ${Math.random() * 30 + 50}%)`
      }));

      function animateBlackHole() {
        ctx.clearRect(0, 0, elements.blackHoleCanvas.width, elements.blackHoleCanvas.height);
        ctx.globalCompositeOperation = 'lighter';
        particles.forEach(p => {
          p.angle += p.speed;
          p.x = elements.blackHoleCanvas.width / 2 + Math.cos(p.angle) * p.distance;
          p.y = elements.blackHoleCanvas.height / 2 + Math.sin(p.angle) * p.distance;
          p.distance *= 0.995; // Gradually pull particles toward center
          if (p.distance < 10) {
            p.distance = Math.random() * 50 + 50;
            p.angle = Math.random() * Math.PI * 2;
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.opacity;
          ctx.fill();
        });
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        state.blackHoleAnimationFrame = requestAnimationFrame(animateBlackHole);
      }
      animateBlackHole();
    }

    function stopBlackHoleAnimation() {
      cancelAnimationFrame(state.blackHoleAnimationFrame);
      if (elements.blackHoleContainer) {
        elements.blackHoleContainer.classList.add('hidden');
      }
    }

    // Event listeners
    elements.themeToggle.addEventListener('click', () => {
      state.theme = state.theme === 'dark' ? 'light' : 'dark';
      document.body.dataset.theme = state.theme;
      localStorage.setItem('theme', state.theme);
      showAlert(`Theme set to ${state.theme}`);
    });

    elements.sensorToggle.addEventListener('click', () => {
      state.sensorDetectionEnabled = !state.sensorDetectionEnabled;
      localStorage.setItem('sensorDetectionEnabled', state.sensorDetectionEnabled);
      if (state.sensorDetectionEnabled) {
        requestSensorPermissions();
        elements.sensorToggle.classList.add('bg-[var(--success)]', 'text-white');
        showAlert("Proximity and orientation detection enabled");
      } else {
        window.removeEventListener('devicemotion', handleProximityFallback, true);
        window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
        elements.sensorToggle.classList.remove('bg-[var(--success)]', 'text-white');
        showAlert("Proximity and orientation detection disabled");
      }
    });

    elements.settingsButton.addEventListener('click', () => {
      showSettingsModal();
      const save = () => {
        state.alertPitch = elements.alertPitch.value;
        state.vibrationPattern = elements.vibrationPattern.value;
        state.proximityThreshold = elements.proximityThreshold.value;
        localStorage.setItem('alertPitch', state.alertPitch);
        localStorage.setItem('vibrationPattern', state.vibrationPattern);
        localStorage.setItem('proximityThreshold', state.proximityThreshold);
        showAlert('Settings saved!');
        closeSettingsModal();
      };
      const cancel = () => closeSettingsModal();
      elements.settingsSave.onclick = save;
      elements.settingsCancel.onclick = cancel;
      elements.alertPitch.onkeypress = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          save();
        }
      };
      document.onkeydown = (e) => {
        if (e.key === 'Escape') {
          cancel();
        }
      };
    });

    document.addEventListener('DOMContentLoaded', () => {
      document.body.dataset.theme = state.theme;
      startBlackHoleAnimation();
      if (state.sensorDetectionEnabled) {
        requestSensorPermissions();
        elements.sensorToggle.classList.add('bg-[var(--success)]', 'text-white');
      }
    });
  </script>
</body>
</html>
